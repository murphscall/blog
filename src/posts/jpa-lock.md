---
title: "낙관적 락과 비관적 락을 통해 엔티티에 대한 동시성 제어"
date: "2025-09-08"
tags: ["Database"]
description: "낙관적 락과 비관적 락에 대해서 알아보고 동시성 제어에 대한 것도 알아보자."
---


## 트랜잭션 격리 수준

트랜잭션은 ACID(원자성, 일관성, 격리성, 지속성) 을 보장해야한다. 트랜잭션은 원자성, 일관성, 지속성을 보장하지만 문제는 격리성이다.
트랜잭션간에 완벽한 격리를 보장하기 위해선 동시성 측면에서 많은 손해를 본다. 예를 들면, **ANSI 표준**에서는 **트랜잭션 격리 수준을 4단계로 구분하여 병행성과 격리성을 설정**할 수 있는데
**격리성**과 **병행성**은 서로 역비례 관계이므로 무턱대고 격리 수준을 최대로 높이게 되면 성능이 악화될 수 있으므로 적절한 격리 수준 설정이 필요하다.

> ### ANSI 표준이란?
> ANSI는 미국의 표준화 기구이며, 데이터베이스 분야에서는 SQL 문법과 동작을 표준화한다.즉, 데이터베이스 벤더(Oracle, MySQL, PostgreSQL 등 )가 공통적으로 따라야 할 SQL 기본 규칙을 정해둔 것이다. 

> ANSI 표준의 트랜잭션 격리 수준 (SQL 표준에서 정의한 4가지 격리 수준) 4단계 
> 1. `READ UNCOMMITTED`
>    - 다른 트랜잭션이 커밋하지 않은 데이터도 읽을 수 있다.
> 2. `READ COMMITTED`
>    - 커밋된 데이터만 읽을 수 있다.  
> 3. `REPEATABLE READ`
>    - 한번 읽은 데이터는 같은 트랜잭션 안에서 항상 동일하게 보장
> 4. `SERIALIZABLE`
>    - 트랜잭션을 직렬 실행한 것과 같은 효과
>    - 팬텀 리드까지 방지
>    - 격리성은 높아지지만 병행성은 낮아짐 ( 성능 손해가 크다. )

하지만 이런 트랜잭션 격리 수준으로도 해결하지 못하는 문제가 존재한다.

## 두번의 갱신 분실 문제

트랜잭션 격리 수준으로는 해결할 수 없는 문제가 있다.
예를 들어, 게시글의 제목을 두 사용자가 동시에 편집하는 상황을 가정해보자.
최초 게시글 제목은 '나는 개발자이다' 이다.

첫번째 사용자는 이 제목을 '나는 자바 개발자이다'로 변경하고 싶고, 두번째 사용자는 '나는 스프링 개발자이다' 로 변경하고 싶어한다.

사용자 1과 사용자 2 는 동시에 수정 화면에 진입했고, 원하는 내용을 작성한 뒤, 수정 버튼을 클릭했다. 그리고 사용자 1의 트랜잭션이 먼저 커밋되고
사용자 2의 트랜잭션이 커밋되었다. 이 경우 사용자 1의 트랜잭션의 변경내용은 사라지게 되고, 사용자 2의 트랜잭션만이 데이터베이스에 반영된다.

이 경우의 처리 방법은 3가지가 있다.

- **마지막 커밋만 인정하기** : 사용자 1의 변경 내용을 무시하고, 마지막에 커밋한 사용자 2의 내용만을 반영한다.
- **최초 커밋만 인정하기** : 사용자 1이 수정을 완료했으므로, 사용자 2의 변경 사항에 대해 오류를 발생시킨다.
- **충돌하는 내용 병합하기** : 사용자 1과 사용자 2의 변경 사항을 병합한다.


상황에 따라서 위 3가지의 방법 중 적절한 정책을 선택해야한다. 근데, 트랜잭션 격리 수준으로는 **'마지막 커밋만 인정하기' 외의 정책을 구현할 수 없다.**

두번째 사례를 살펴보자. 조금 더 동시성 이슈에 민감한 송금 관련 트랜잭션이다.

계좌에는 10,000원이 있는 상황이다. 사용자 1은 50,000원을 입금하고, 사용자 2는 10,000원을 입금 하는 상황이다.
입금을 위해서는 현재 계좌의 잔액을 읽어오고 입금액을 더한 값으로 잔액을 갱신해야한다. 사용자 1의 트랜잭션이 먼저 시작되어 잔액 10,000원을 읽어왔다.
그 후 근소한 차이로 사용자 2의 트랜잭션이 마찬가지로 잔액 10,000원을 읽어왔다.
사용자 1의 트랜잭션은 읽어온 10,000원에 입금액 50,000원 을 더해 60,000으로 잔액을 갱신하고 커밋한다. 이후 사용자 2의 트랜잭션은 읽어온 10,000원에 입금액 10,000원을 더한 20,000으로 잔액을 갱신하고 커밋한다.

이 상황에서 사용자 1 트랜잭션의 송금 내역은 분실된다. 절대 일어나서는 안되는 일이다.

트랜잭션 격리 레벨로 이 문제를 어떻게 풀 수 있을까?
`REPEATABLE READ` 는 조회한 데이터가 트랜잭션 동안 일관적으로 같은 값을 읽어올 수 있는 정도의 격리 수준을 제공한다. 그래서 이상의 레벨이 필요한데,
`SERIALIZABLE` 이다.  MySQL 기준으로 `SERIALIZABLE`은 읽기 작업을 하는 데이터에 대해서도 shared lock을 건다.
일관된 읽기 뿐 아니라 실제 읽고 있는 데이터가 다른 트랜잭션에 의해서 변경되지 않음을 보장할 수 있다.

그러면 `SERIALIZABLE`로 문제가 해결이 될까? 이 경우 두 트랜잭션이 같은 데이터에 대해 s-lock을 걸고 그 직후 서로 x-lock을 거는 상황이 연출되는데, 이 경우 **데드락이 발생한다.**
s-lock과 x-lock은 양립할 수 없기 때문이다.

> **s-lock** 
> 
> 여러 트랜잭션이 동시에 읽을 수 있지만 (공유 가능) 쓰기는 불가능하다.
> 
> **x-lock**
> 
> 한 트랜잭션만 해당 자원에 접근 가능하며 읽기와 쓰기 모두 잠금된다. 한 사용자가 게시글을 수정 중이면, 다른 사용자는 읽기/쓰기 모두 대기해야한다.

두 트랜 잭션은 x-lock을 걸기 위해 서로가 s-lcok을 해제하는 시점을 무한히 대기하며 타임아웃될 것이다. 물론, 동시성 이슈는 당장 해결되겠지만 데드락이 발생하는 해결 방법을 정상적인 해결 방법으로 볼 수는 없다.

위와 같은 문제를 두번의 갱실 분실 문제 라고 부른다. 이와 같이 두번의 갱신 분실 문제와  같은 경우 트랜잭션으로 처리할 수 있는 범위를 넘어선다.
따라서 별도의 방법이 필요하다.

## 낙관적 락과 비관적 락

JPA는 데이터베이스에 대한 동시 접근으로부터 엔티티에 대한 무결성을 유지할 수 있게 해주는 동시성 제어 매커니즘을 지원한다.
이 매커니즘에는 낙관적 락과 비관적 락이 존재한다. JPA는 이 데이터베이스의 트랜잭션 격리 레벨을 READ COMMITTED 정도로 가정한다.

## 낙관적 락 (Optimistic Lock)

대부분의 트랜잭션이 충돌이 발생하지 않을 것이라고 낙관적으로 가정하는 방법이다.
따라서 데이터베이스가 제공하는 락 기능을 사용하지 않고, 엔티티의 버전을 통해 동시성을 제어한다. 즉, 애플리케이션 레벨에서 지원하는 락이다.

### @Version
JPA는 `@Version` 어노테이션을 제공하는데, 이를 사용하여 엔티티의 버전을 관리할 수 있다.
`@Version` 적용이 가능한 타입은 `Long`, `Integer`, `Short`, `Timestamp` 이다. `@Version` 은 아래와 같이 버전 관리용 필드를 만들어 적용한다.

```java
@Entity
public class Board {

  @Id
  private String id;
  private String title;

  @Version
  private Integer version;
}
```

위 `Board` 엔티티가 변경될 때 마다 `version` 이 자동으로 하나씩 증가한다.
그리고 엔티티를 수정할 때, 엔티티를 조회한 시점의 버전과 수정한 시점의 버전이 일치하지 않으면 예외가 발생한다.

두 번의 갱신 분실 문제에서 첫 번째로 예시로 들었던 게시글 제목 사례를 생각해보자.
사용자 1의 트랜잭션과 사용자 2의 트랜잭션이 조회한 엔티티의 버전이 1이라고 가정하자.
사용자 1의 트랜잭션이 2의 트랜잭션 보다 먼저 엔티티를 수정하고 커밋했다면 엔티티의 버전은 2가 되었을 것이다.
이후 사용자 2의 트랜잭션이 엔티티를 수정하고 커밋하려한다.
조회한 시점에는 엔티티의 버전이 1이었는데, 수정한 시점에는 2가 되었으니 버전의 불일치가 발생했으므로 예외가 발생한다.
즉, '최초 커밋만 인정하기' 정책을 구현할 수 있다.

### 버전 정보 비교 방법
JPA가 엔티티를 수정하고 트랜잭션을 커밋하는 시점에, 영속성 컨텍스트를 flush 하면서 아래의 `UPDATE` 쿼리를 실행한다.

```java 
UPDATE BOARD
SET
  title = ?,
  version = ? # 버전 + 1 증가
WHERE
  id = ?,
  and version = ? # 버전 비교
```

위와 같이 데이터가 수정되었을 때, 엔티티의 버전 정보를 증가시킨다.
위 쿼리에서 `WHERE` 절에서 엔티티 조회 시점의 버전으로 데이터를 찾는 조건을 볼 수 있다.
만약 데이터 조회 이후 엔티티가 수정되었다면 위 `WHERE` 문으로 엔티티를 찾을 수 없다. 이 때 JPA가 예외를 던진다.

### 주의점

Embedded 타입의 경우 논리적으로 해당 엔티티의 값이므로 수정하면 엔티티의 버전이 증가한다.
반면 연관관계 필드의 경우 연관관계의 주인 필드를 변경할 때에만 버전이 증가한다.

또, @Version 으로 추가한 버전 관리 필드는 JPA가 직접 관리하므로 임의로 수정해서는 안된다.
그런데 벌크 연산의 경우 버전을 무시하므로, 벌크 연산을 수행할 때에는 아래와 같이 버전 필드를 강제로 증가 시켜야한다.

> **벌크 연산이란..?**
> 
> JPA는 보통 엔티티 단위로 변경을 감지해서 SQL 을 실행한다. 하지만 벌크 연산은 JPQL로 직접 여러 행을 한 번에 `UPDATE / DELETE` 하는 것이다.
> 일반 UPDATE 의 경우 엔티티 -> 연속성 컨텍스트 -> SQL 실행의 순서로 항상 엔티티를 거쳐야한다.
> 반면에 벌크연산의 경우 엔티티를 전혀 거치치 않고 바로 DB에서 SQL이 실행되기 때문에 version 도 함께 증가시켜야하는 것이다.

```java 
update Member m set m.name = '변경', m.version = m.version + 1
```


## 낙관적 락의 LockModeType
LockModeType 을 통해서 락 옵션을 변경할 수 있다.

### None
별도로 락 옵션을 지정하지 않아도 엔티티에 `@Version` 을 적용하면 기본적으로 적용되는 락 옵션이다.
- **용도** : 조회한 엔티티를 수정하는 시점에 다른 트랜잭션으로부터 변경 되지 않음을 보장한다. 즉, 조회 시점부터 수정 시점까지를 보장한다.
- **동작** : 엔티티를 수정하는 시점에 엔티티의 버전을 증가시킨다. 이때 엔티티의 버전이 조회 시점과 다르다면 예외가 발생한다.
- **이점** : 두 번의 갱신 분실 문제를 해결한다.

### OPTIMISTIC
`NONE` 의 경우 엔티티를 수정해야 버전을 체크하지만, 이 옵션은 엔티티를 조회만 해도 버전을 체크한다.
즉, 한번 조회한 엔티티가 트랜잭션 동안 변경되지 않음을 보장한다.
- **용도** : 엔티티의 조회 시점부터 트랜잭션이 끝날 때 까지 다른 트랜잭션에 의해 변경되지 않음을 보장한다.
- **동작** : 트랜잭션을 커밋하는 시점에 버전 정보를 체크한다.
- **이점** : 애플리케이션 레벨에서 DIRTY READ와 NON-REPEATABLE READ를 방지한다.


### OPTIMISTICFORCEINCREMENT
낙관적 락을 사용하면서 버전 정보를 강제로 증가한다. 엔티티가 물리적으로 변경되지 않았지만, 논리적으로 변경되었을 경우 버전을 증가하고 싶을 때 사용한다.

예를 들어 게시물과 첨부파일 엔티티가 1:N 관계로 있다고 가정하자. 게시물에 첨부파일이 하나 추가된 상황은 게시물 엔티티의 물리적 변경은 일어나지 않았지만, 논리적인 변경은 일어났다.
이때 버전을 변경하고 싶다면 해당 락 옵션을 사용하면 된다.
- **용도** : 논리적인 단위의 엔티티 묶음을 관리할 수 있다.
- **동작** : 엔티티가 직접적으로 수정되어 있지 않아도, 트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해 버전 정보를 강제로 증가시킨다. 이때 엔티티의 버전을 체크하고 일치하지 않으면 예외가 발생한다. 이때 추가로 엔티티의 정보도 실제로 변경되었다면 2번의 버전 증가가 발생한다.
- **이점** : 강제로 버전을 변경하여 논리적인 단위의 엔티티 묶음을 버전관리할 수 있다.


## 비관적 락 (Perssimistic Lock)

비관적 락은 실제로 데이터베이스의 락을 사용하여 동시성을 제어하는 방법이다. 주로 쿼리에 `SELECT ... FOR UPDATE` 구문을 사용하고, 버전 정보는 사용하지 않는다.
락을 직접 걸기 때문에 아래의 두 가지 특징을 가지고 있다.

1. 엔티티가 아닌 스칼라 타입을 조회할 때도 사용할 수 있다.
2. 데이터를 수정하는 즉시 트랜잭션의 충돌을 감지 할 수 있다.

> #### 스칼라타입이란?
> DB 컬럼 값 자체만 가져오는 타입 (숫자, 문자열 등)
> `User` 엔티티 전체를 조회하면 엔티티 조회이고 `username`, `age` 같은 컬럼만 조회하면 스칼라 타입 조회이다.
> 

## 비관적 락의 LockModeType

### PERSSIMISTIC_WRITE

> **베타락**
> 동시에 하나만 접근 가능한 락
> 어떤 트랜잭션이 데이터에 베타락(x-lock) 을 걸면 다른 트랜잭션은 그 데이터에 **읽기(s-lock)**도 , **쓰기 (x-lock)** 도 불가능하며, 대기상태이다.

비관적 락이라고 하면 일반적으로 해당 옵션을 의미한다.
- **용도/동작**  : 데이터베이스에 `SELECT ... FOR UPDATE` 를 사용하여 베타 락을 건다.
- **이점** : NON-REPEATABLE READ를 방지한다.

### PESSIMISTIC_READ
데이터를 반복 읽기만 하고 수정하지 않을 때 사용한다. 일반적으로는 잘 사용하지 않는다고 한다. 데이터베이스 대부분으 방언에 의해 PERSSIMISTIC_WRITE로 동작한다.
- **동작** : 동작 : `SELECT ... FOR SHARE (LOCK IN SHARE MODE)`


### PESSIMISTICFORCEINCREMENT
비관적 락 중 유일하게 버전 정보를 사용한다. 비관적 락이지만 버전 정보를 강제적으로 증가ㅏ시킨다.
하이버네이트의 경우 `nowait` 을 지원하는 데이터베이스에 대해서 `FOR UPDATE NOWAIT` 옵션을 적용하고, 그렇지 않다면 `FOR UPDATE` 을 적용한다.

## 동시성 제어 매커니즘과 트랜잭션 격리 수준의 차이점
낙관락/ 비관락 같은 JPA의 동시성 제어 매커니즘과 DBMS의 트랜잭션 격리 수준의 차이점이 잘 구분되지 않아 혼란스러웠다.

결론부터 이야기하자면 JPA의 동시성 제어 매커니즘은 특정 엔티티에 대한 동시 접근을 막기 위해 사용한다.
반면, 트랜잭션 격리 수준은 트랜잭션 동안의 일관된 데이터 읽기를 고려하기 위해 적용한다.

DBMS에 따라 격리 레벨에 대한 세부 구현은 다르겠지만, 대부분의 데이터베이스는 트랜잭션 격리 레벨을 구현할 때 락을 사용하지 않는다고 한다.
자세히 공부하진 않았지만, MySQL 만해도 트랜잭션 내부에서 일관된 읽기를 구현하기 위해 락 대신 MVCC 를 사용한다. 특별한 예외로는 SERIALIZABLE 은 조회 중인 데이터를 다른 트랜잭션이 변경하려고 할 때 락을 획득한다.

반면 낙관락/ 비관락은 그 관심사가 엔티티에 대한 동시 접근에 대한 처리이다. 한 트랜잭션이 특정 엔티티에 접근하고 있을 때 다른 트랜잭션이 해당 엔티티를 변경할 수 없도록 버전을 사용하거나 락을 걸어 해결한다.
즉, 트랜잭션 격리 수준과는 관계가 없다.


## Reference Blog
- https://eastshine12.tistory.com/68
- https://stackoverflow.com/questions/22646226/how-are-locking-mechanisms-pessimistic-optimistic-related-to-database-transact
- https://hudi.blog/jpa-concurrency-control-optimistic-lock-and-pessimistic-lock/

